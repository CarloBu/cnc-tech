---
export interface Props {
	id: string;
	src: string;
	loop?: boolean;
	segments?: [number, number];
	class?: string;
	rotate?: 'clockwise' | 'counter-clockwise' | 'none';
	rotationSpeed?: number;
	fillScreen?: boolean;
	removeAfterPlay?: boolean;
}

const {
	id,
	src,
	loop = false,
	segments,
	class: className = '',
	rotate = 'none',
	rotationSpeed = 60,
	fillScreen = false,
	removeAfterPlay = false,
} = Astro.props;
---

<div id={id} class={`lottie-layer ${className}`}></div>

<script define:vars={{ id, src, loop, segments, rotate, rotationSpeed, fillScreen, removeAfterPlay }}>
	document.addEventListener('DOMContentLoaded', () => {
		const initLottie = () => {
			if (!window.lottie) {
				setTimeout(initLottie, 50);
				return;
			}

			const container = document.getElementById(id);
			if (!container) {
				console.error(`Lottie container with ID "${id}" not found`);
				return;
			}

			const animation = window.lottie.loadAnimation({
				container: container,
				renderer: 'svg',
				loop: loop || false,
				autoplay: true,
				path: src,
				rendererSettings: {
					preserveAspectRatio: fillScreen ? 'none' : 'xMidYMid meet',
					progressiveLoad: false,
				},
			});

			animation.addEventListener('DOMLoaded', () => {
				const svg = container.querySelector('svg');
				if (svg) {
					if (fillScreen) {
						// Scale to fill screen
						svg.style.width = '100%';
						svg.style.height = '100%';
						svg.style.position = 'absolute';
						svg.style.top = '0';
						svg.style.left = '0';
					} else {
						// Scale only height, keep aspect ratio
						svg.style.width = 'auto';
						svg.style.height = '100%';
						svg.style.minWidth = '100%';
						svg.style.position = 'absolute';
						svg.style.left = '50%';
						svg.style.transform = 'translateX(-50%)';
					}
				}
			});

			window.lottie.setQuality('high');

			// Handle removeAfterPlay functionality
			if (removeAfterPlay && !loop) {
				animation.addEventListener('complete', () => {
					// Remove the container from DOM
					if (container && container.parentNode) {
						container.parentNode.removeChild(container);
					}
				});
			}

			if (segments && !loop) {
				animation.addEventListener('complete', () => {
					animation.playSegments(segments, true);
					animation.loop = true;
				});
			}

			// Handle rotation
			if (rotate && rotate !== 'none') {
				const direction = rotate === 'clockwise' ? 1 : -1;
				const duration = rotationSpeed * 3600;
				let startTime = null;
				let currentRotation = 0;

				const animateRotation = (timestamp) => {
					if (!startTime) startTime = timestamp;
					const elapsed = timestamp - startTime;

					const progress = (elapsed % duration) / duration;
					currentRotation = progress * 360 * direction;

					container.style.transformOrigin = '50% 53.24%';
					container.style.transform = `rotate(${currentRotation}deg)`;

					requestAnimationFrame(animateRotation);
				};

				requestAnimationFrame(animateRotation);
			}
		};

		initLottie();
	});
</script>

<style>
	.lottie-layer {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		pointer-events: none;
		z-index: inherit;
		overflow: hidden;
	}
</style>
